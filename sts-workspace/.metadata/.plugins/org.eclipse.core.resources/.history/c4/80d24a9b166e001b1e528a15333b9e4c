package com.lyncwork.services.hellosign.service;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import com.lyncwork.services.hellosign.client.dropbox.client.member.DropboxMemberClientFeign;
import com.lyncwork.services.hellosign.client.dropbox.client.teamfolder.ContentClientFeign;
import com.lyncwork.services.hellosign.client.dropbox.client.teamfolder.FilesClientFeign;
import com.lyncwork.services.hellosign.client.dropbox.client.teamfolder.TeamFolderClientFeign;
import com.lyncwork.services.hellosign.client.dropbox.config.CustomInputStream;
import com.lyncwork.services.hellosign.client.dropbox.model.request.member.list.ListMemberRequest;
import com.lyncwork.services.hellosign.client.dropbox.model.request.teamfolder.ApiPathRoot;
import com.lyncwork.services.hellosign.client.dropbox.model.request.teamfolder.FilePath;
import com.lyncwork.services.hellosign.client.dropbox.model.request.teamfolder.create.CreateTeamFolderRequest;
import com.lyncwork.services.hellosign.client.dropbox.model.request.teamfolder.create.UploadHeaderArgument;
import com.lyncwork.services.hellosign.client.dropbox.model.request.teamfolder.list.ListFolderRequest;
import com.lyncwork.services.hellosign.client.dropbox.model.response.Namespace;
import com.lyncwork.services.hellosign.client.dropbox.model.response.member.list.ListMember;
import com.lyncwork.services.hellosign.client.dropbox.model.response.teamfolder.content.ContentUploadResponse;
import com.lyncwork.services.hellosign.client.dropbox.model.response.teamfolder.create.CreateTeamFolderResponse;
import com.lyncwork.services.hellosign.client.dropbox.model.response.teamfolder.list.GetNamespcesResponse;
import com.lyncwork.services.hellosign.client.dropbox.model.response.teamfolder.list.ListFolderResponse;
import com.lyncwork.services.hellosign.client.dropbox.utils.Constants;
import com.lyncwork.services.hellosign.client.dropbox.utils.JsonUtils;
import com.lyncwork.services.hellosign.domain.Company;
import com.lyncwork.services.hellosign.domain.enumeration.UserRole;
import com.lyncwork.services.hellosign.errors.FileNotFoundException;
import com.lyncwork.services.hellosign.errors.InternalBusinessException;
import com.lyncwork.services.hellosign.model.request.ProvisionTenantRequest;
import com.lyncwork.services.hellosign.model.response.*;
import com.lyncwork.services.hellosign.repository.CompanyRepository;
import com.lyncwork.services.hellosign.service.dto.CompanyDTO;
import com.lyncwork.services.hellosign.service.dto.FileDTO;
import com.lyncwork.services.hellosign.service.dto.UserDTO;
import com.lyncwork.services.hellosign.service.mapper.CompanyMapper;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Service Implementation for managing {@link CompanyService}.
 */
@Service
@Transactional
public class CompanyService {

    @Autowired
    private TeamFolderClientFeign teamFolderClientFeign;

    @Autowired
    private DropboxMemberClientFeign dropboxMemberClientFeign;

    @Autowired
    private FilesClientFeign filesClientFeign;

    @Autowired
    private CompanyRepository companyRepository;

    @Autowired
    private ContentClientFeign contentClientFeign;

    @Autowired
    private FileService fileService;

    @Autowired
    private UserService userService;

    @Autowired
    private CompanyMapper  companyMapper;

    private final Logger log = LoggerFactory.getLogger(CompanyService.class);

    public static ConcurrentHashMap<String, String> defaultDropboxHeaderValues = new ConcurrentHashMap();

    @Autowired
    private MessageSource messageSource;

    @Value("${dropbox.space}")
    private String envDropboxSpace;

    public ProvisionTenantResponse provisionTenant(String tenantId, ProvisionTenantRequest provisionTenant) {

        CreateTeamFolderResponse createTeamFolderResponse = null;
        ProvisionTenantResponse provisionTenantResponse = new ProvisionTenantResponse();
        checkAndupdateEnvironmentFolder();
        Company company = companyRepository.findByTenantId(tenantId);
        if (company != null) {
            provisionTenantResponse.setParentFolderId(company.getPerentSharedFolderId());
            provisionTenantResponse.setFolderName(company.getTeamFolderName());
        } else {

            Map<String, String> headers = new HashMap<String, String>();
            headers.put(Constants.DROPBOX_API_SELECT_USER, getLyncWorkDropboxAdmin());
            headers.put(Constants.DROPBOX_API_PATH_ROOT, getTenantApiPathRoot(tenantId));

            CreateTeamFolderRequest createTeamFolderRequest = new CreateTeamFolderRequest();
            createTeamFolderRequest.setPath("/" + provisionTenant.getCompanyName() + "_" + tenantId);
            createTeamFolderRequest.setAutoRename(false);

            createTeamFolderResponse = filesClientFeign.createTeamFolder(createTeamFolderRequest, headers);

            log.info("createTeamFolderResponse: {}", createTeamFolderResponse);

            company = new Company();
            company.setTenantId(tenantId);
            company.setTeamFolderName(createTeamFolderResponse.getMetadata().getPathDisplay());
            company.setCompanyName(provisionTenant.getCompanyName());
            company.setFolderId(createTeamFolderResponse.getTeamFolderId());
            company.setTeamFolderNameSpaceId(defaultDropboxHeaderValues.get(Constants.ROOT_FOLDER_NAMESPACE_ID));
            company.setPerentSharedFolderId(createTeamFolderResponse.getMetadata().getParentFolderId());
            companyRepository.save(company);

            provisionTenantResponse.setFolderName(createTeamFolderResponse.getMetadata().getPathDisplay());
            provisionTenantResponse.setParentFolderId(createTeamFolderResponse.getMetadata().getParentFolderId());
        }
        return provisionTenantResponse;
    }

    public UploadResponse upload(MultipartFile file, String tenantId, String owner) {

        UploadResponse uploadResponse = new UploadResponse();

        Optional<CompanyDTO>  optionalCompanyDTO = findCompanyByTenatId(tenantId);
        if (optionalCompanyDTO.isEmpty()) {
            throw new InternalBusinessException(messageSource.getMessage("dropbox.tenant.not.provisioned", null, null), CompanyService.class.getSimpleName(), "companynotexist");
        }

        CompanyDTO companyDTO = optionalCompanyDTO.get();

        UploadHeaderArgument uploadHeaderArgument = new UploadHeaderArgument();
        uploadHeaderArgument.setPath(companyDTO.getTeamFolderName() + "/" + file.getOriginalFilename());
        uploadHeaderArgument.setMode("add");
        uploadHeaderArgument.setAutorename(false);
        uploadHeaderArgument.setMute(false);
        uploadHeaderArgument.setStrictConflict(true);
        String argument = JsonUtils.writeValueAsString(uploadHeaderArgument);

        Map<String, String> headers = new HashMap<String, String>();
        headers.put(Constants.DROPBOX_API_ARG, argument);
        headers.put(Constants.DROPBOX_API_SELECT_USER, getLyncWorkDropboxAdmin());
        headers.put(Constants.DROPBOX_API_PATH_ROOT, getTenantApiPathRoot(tenantId));

        byte[] fileToUpload = null;
        try {
            fileToUpload = IOUtils.toByteArray(file.getInputStream());
        } catch (IOException e) {
            log.error("Error handling the file to upload {}", e.getMessage(), e);
            throw new InternalBusinessException(messageSource.getMessage("dropbox.file.unexpected.error", new String[]{e.getMessage()}, null), CompanyService.class.getSimpleName(), "companynotexist");
        }

        Optional<FileDTO> optionalFileDTO = fileService.findByFilePath(companyDTO.getTeamFolderName() + "/" + file.getOriginalFilename());

        ContentUploadResponse contentUploadResponse = null;
        if (optionalFileDTO.isEmpty()) {

            contentUploadResponse = contentClientFeign.upload(fileToUpload, headers);
            log.debug("Dropbox upload response: {}", contentUploadResponse);
            Optional<UserDTO> optionalUserDTO = userService.findUserByUserNameAndCompanyId(owner, companyDTO.getId());

            UserDTO userDTO = null;

            if (optionalUserDTO.isEmpty()) {
                userDTO = new UserDTO();
                userDTO.setCompany(companyDTO);
                userDTO.setUsername(owner);
                userDTO.setUserRole(UserRole.ADMIN);
                userDTO = userService.save(userDTO);
            }else{
                userDTO =  optionalUserDTO.get();
            }
           FileDTO fileDTO = new FileDTO();
           fileDTO.setFileName(file.getOriginalFilename());
           fileDTO.setFilePath(contentUploadResponse.getPathDisplay());
           fileDTO.setFileOwner(userDTO);
           fileDTO.setDropboxFileId(contentUploadResponse.getId());
           fileService.save(fileDTO);

        }
        uploadResponse.setFileId(contentUploadResponse.getId());
        uploadResponse.setFileName(contentUploadResponse.getName());

        return  uploadResponse;
    }

    public DownloadResponse download(String fileId, String tenantId) {

        Optional<CompanyDTO>  optionalCompanyDTO = findCompanyByTenatId(tenantId);
        CustomInputStream response= null;
        if(optionalCompanyDTO.isPresent()){

           Optional<FileDTO> optionalFileDTO = fileService.findByDropboxFileId(fileId);

           if(optionalFileDTO.isPresent()){
               FileDTO fileDTO = optionalFileDTO.get();

               if(!fileDTO.getFilePath().startsWith(optionalCompanyDTO.get().getTeamFolderName())){

                   throw new FileNotFoundException(messageSource.getMessage("dropbox.file.not.found", new String[]{fileId}, null), CompanyService.class.getSimpleName(), "companynotexist");
               }

               FilePath filePath = new FilePath(fileDTO.getFilePath());

               Map<String, String> headers = new HashMap<String, String>();
               headers.put(Constants.DROPBOX_API_ARG, JsonUtils.writeValueAsString(filePath));
               headers.put(Constants.DROPBOX_API_SELECT_USER, getLyncWorkDropboxAdmin());
               headers.put(Constants.DROPBOX_API_PATH_ROOT, getTenantApiPathRoot(tenantId));
               response = contentClientFeign.download(headers);

               log.info("ContentDownloadResponse **** {}", response);
           } else{

               throw new FileNotFoundException(messageSource.getMessage("dropbox.file.not.found", new String[]{fileId}, null), CompanyService.class.getSimpleName(), "companynotexist");
           }
        }else{

            throw new InternalBusinessException(messageSource.getMessage("dropbox.tenant.not.provisioned", null, null), CompanyService.class.getSimpleName(), "companynotexist");
        }

        ByteArrayResource resources = null;

        try {
            File file = File.createTempFile(response.getFileName(), response.getExtension());
            FileUtils.writeByteArrayToFile(file, response.getData());

            resources = new ByteArrayResource(Files.readAllBytes(Paths.get(file.getAbsolutePath())));

        } catch (IOException e) {
            log.error(e.getMessage(),e);
            throw new InternalBusinessException(messageSource.getMessage("dropbox.file.unexpected.error", new String[]{e.getMessage()}, null), CompanyService.class.getSimpleName(), "companynotexist");
        }
        DownloadResponseHeader downloadResponseHeader = new DownloadResponseHeader();
        downloadResponseHeader.setId(response.getFileId());
        downloadResponseHeader.setName(response.getFileName()+response.getExtension());
        downloadResponseHeader.setSize(response.getSize());
        DownloadResponse downloadResponse = new DownloadResponse();
        downloadResponse.setData(resources);
        downloadResponse.setFileInfo(JsonUtils.writeValueAsString(downloadResponseHeader));

        return downloadResponse;
    }

    public ListFilesResponse getTeamFileList(String tenantId) {

        List<FileInfo>  fileInfos = new ArrayList<>();
        Optional<CompanyDTO>  optionalCompanyDTO = findCompanyByTenatId(tenantId);
        ListFilesResponse listFilesResponse = new ListFilesResponse();
        if (optionalCompanyDTO.isEmpty()) {

            throw new InternalBusinessException(messageSource.getMessage("dropbox.tenant.not.provisioned", null, null), CompanyService.class.getSimpleName(), "companynotexist");
        }

        CompanyDTO companyDTO = optionalCompanyDTO.get();
        ListFolderRequest arguments = new ListFolderRequest();
        arguments.setPath(companyDTO.getTeamFolderName());
        arguments.setRecursive(false);
        arguments.setIncludeDeleted(false);
        arguments.setIncludeMediaInfo(false);
        arguments.setIncludeHasExplicitSharedMembers(false);
        arguments.setIncludeMountedFolders(true);
        arguments.setIncludeNonDownloadableFiles(true);

        Map<String, String> headers = new HashMap<String, String>();
        headers.put(Constants.DROPBOX_API_SELECT_USER, getLyncWorkDropboxAdmin());
        headers.put(Constants.DROPBOX_API_PATH_ROOT, getTenantApiPathRoot(tenantId));

        ListFolderResponse listFolderResponse = filesClientFeign.listFolder(arguments, headers);
        log.info("listFolderResponse **** {}", listFolderResponse);

        if(listFolderResponse!= null && !CollectionUtils.isEmpty(listFolderResponse.getEntries())){

            fileInfos = listFolderResponse.getEntries().stream().map(m->{
                FileInfo info = new FileInfo();
                info.setId(m.getId());
                info.setName(m.getName());
                info.setDownloadable(m.getDownloadable());
                info.setSize(m.getSize());
                return info;
            }).collect(Collectors.toList());
        }

        listFilesResponse.setFileInfos(fileInfos);

        return listFilesResponse;
    }

    private String getApiPathRoot1() {

        String apiPathRoot = defaultDropboxHeaderValues.get(Constants.DROPBOX_API_PATH_ROOT);
        if(StringUtils.isEmpty(apiPathRoot)){
            GetNamespcesResponse namespacesResponse = teamFolderClientFeign.getNamespaces("{}");
            Optional<String> namespaceId = namespacesResponse.getNamespaces().stream()
                    .filter(n -> Constants.ROOT_FOLDER_NAME.equalsIgnoreCase(n.getName()))
                    .map(n -> n.getNamespaceId())
                    .findFirst();

            if (namespaceId.isPresent()) {
                apiPathRoot = JsonUtils.writeValueAsString(new ApiPathRoot(Constants.NAME_SPACE_ID, namespaceId.get()));
                defaultDropboxHeaderValues.put(Constants.DROPBOX_API_PATH_ROOT, apiPathRoot);
            }
        }

        return apiPathRoot;
    }

    private String getTenantApiPathRoot(String tenantId) {

        String apiPathRoot = defaultDropboxHeaderValues.get(Constants.ENVIRONMENT_API_PATH_ROOT);
        if(StringUtils.isEmpty(apiPathRoot)){
            //lookup environment folder into database
            Optional<CompanyDTO> optionalCompanyDTO = findCompanyByTenatId(tenantId);
            if (optionalCompanyDTO.isPresent() && !StringUtils.isEmpty(optionalCompanyDTO.get().getPerentSharedFolderId())) {

                apiPathRoot = JsonUtils.writeValueAsString(new ApiPathRoot(Constants.NAME_SPACE_ID, optionalCompanyDTO.get().getPerentSharedFolderId()));
                defaultDropboxHeaderValues.put(Constants.ENVIRONMENT_API_PATH_ROOT, apiPathRoot);
            } else {
                //lookup environment folder rood path
                GetNamespcesResponse namespacesResponse = teamFolderClientFeign.getNamespaces("{}");
                log.debug("NamespacesResponse: {}", namespacesResponse);

                for (Namespace namespace :namespacesResponse.getNamespaces()) {

                    if(namespace.getName().equalsIgnoreCase(Constants.ROOT_FOLDER_NAME)){

                        defaultDropboxHeaderValues.put(Constants.PARENT_FOLDER_NAMESPACE_ID, namespace.getNamespaceId());

                    } else if(namespace.getName().equalsIgnoreCase(envDropboxSpace)){

                        defaultDropboxHeaderValues.put(Constants.ENVIRONMENT_FOLDER_NAMESPACE_ID, namespace.getNamespaceId());
                    }
                }
                if (!StringUtils.isEmpty(defaultDropboxHeaderValues.get(Constants.ENVIRONMENT_FOLDER_NAMESPACE_ID))){
                    //environment folder exist already
                    apiPathRoot = JsonUtils.writeValueAsString(new ApiPathRoot(Constants.NAME_SPACE_ID, defaultDropboxHeaderValues.get(Constants.ENVIRONMENT_FOLDER_NAMESPACE_ID)));
                    defaultDropboxHeaderValues.put(Constants.ENVIRONMENT_API_PATH_ROOT, apiPathRoot);

                } else {

                    throw new InternalBusinessException(messageSource.getMessage("dropbox.file.unexpected.error", new String[]{"remote environment folder could not be accessed"}, null), CompanyService.class.getSimpleName(), "companynotexist");

                }
            }
        }
        return apiPathRoot;
    }

    private String getLyncWorkDropboxAdmin(){
        String adminId = defaultDropboxHeaderValues.get(Constants.DROPBOX_API_SELECT_USER);

        if(StringUtils.isEmpty(adminId)) {

            ListMemberRequest listMemberRequest = new ListMemberRequest();
            listMemberRequest.setLimit(500);
            listMemberRequest.setIncludeRemoved(false);
            ListMember listMembers = dropboxMemberClientFeign.getMembers(listMemberRequest);
            log.info("listMembers: {}", listMembers);
            Optional<String> optionalAdminId = listMembers.getMembers().stream()
                    .filter(m -> Constants.TEAM_ADMIN.equalsIgnoreCase(m.getRole().getTag()))
                    .filter(m -> Constants.TEAM_ACTIVE_STATUS.equalsIgnoreCase(m.getProfile().getStatus().getTag()))
                    .map(m -> m.getProfile().getTeamMemberId())
                    .findFirst();

            if (optionalAdminId.isPresent()) {
                adminId = optionalAdminId.get();
                defaultDropboxHeaderValues.put(Constants.DROPBOX_API_SELECT_USER, adminId);
            }
        }
        return adminId;
    }

    @Transactional(readOnly = true)
    public Optional<CompanyDTO> findCompanyByTenatId(String tenantId) {
        log.debug("Request to get company by tenant id: {}", tenantId);
        Company company = companyRepository.findByTenantId(tenantId);
        CompanyDTO companyDTO = companyMapper.toDto(company);
        return Optional.ofNullable(companyDTO);
    }

    @Transactional(readOnly = true)
    public CompanyDTO save(CompanyDTO companyDTO) {
        log.debug("Request to save companyDTO : {}", companyDTO);
        Company company = companyMapper.toEntity(companyDTO);
        company = companyRepository.save(company);
        CompanyDTO result = companyMapper.toDto(company);
        return result;
    }


    public void checkAndupdateEnvironmentFolder() {
        if (StringUtils.isEmpty(defaultDropboxHeaderValues.get(Constants.ENVIRONMENT_FOLDER_NAMESPACE_ID))) {
            GetNamespcesResponse namespacesResponse = teamFolderClientFeign.getNamespaces("{}");
            log.debug("NamespacesResponse: {}", namespacesResponse);

            for (Namespace namespace : namespacesResponse.getNamespaces()) {

                if (namespace.getName().equalsIgnoreCase(Constants.ROOT_FOLDER_NAME)) {
                    defaultDropboxHeaderValues.put(Constants.PARENT_FOLDER_NAMESPACE_ID, namespace.getNamespaceId());
                } else if (namespace.getName().equalsIgnoreCase(envDropboxSpace)) {
                    defaultDropboxHeaderValues.put(Constants.ENVIRONMENT_FOLDER_NAMESPACE_ID, namespace.getNamespaceId());
                }
            }

            if (StringUtils.isEmpty(defaultDropboxHeaderValues.get(Constants.ENVIRONMENT_FOLDER_NAMESPACE_ID))) {
                //create environment folder
                if (!StringUtils.isEmpty(defaultDropboxHeaderValues.get(Constants.PARENT_FOLDER_NAMESPACE_ID))) {
                    // We should have the root folder so create the environment folder

                    Map<String, String> headers = new HashMap<String, String>();
                    headers.put(Constants.DROPBOX_API_SELECT_USER, getLyncWorkDropboxAdmin());
                    headers.put(Constants.DROPBOX_API_PATH_ROOT, JsonUtils.writeValueAsString(new ApiPathRoot(Constants.NAME_SPACE_ID, defaultDropboxHeaderValues.get(Constants.PARENT_FOLDER_NAMESPACE_ID))));

                    CreateTeamFolderRequest createTeamFolderRequest = new CreateTeamFolderRequest();
                    createTeamFolderRequest.setPath("/" + envDropboxSpace);
                    createTeamFolderRequest.setAutoRename(false);

                    //Create environment folder
                    CreateTeamFolderResponse createTeamFolderResponse = filesClientFeign.createTeamFolder(createTeamFolderRequest, headers);
                    log.debug("createTeamFolderResponse: {}", createTeamFolderResponse);

                } else {

                    throw new InternalBusinessException(messageSource.getMessage("dropbox.file.unexpected.error", new String[]{"remote team folder does not exist"}, null), CompanyService.class.getSimpleName(), "companynotexist");
                }
            }
        }
    }
}
