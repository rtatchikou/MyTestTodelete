package com.multipart.multipart;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.StreamUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;

import rpil.framework.lib.base.error.ResponseException;
import rpil.framework.lib.base.error.RpilJsonException;
import rpil.framework.lib.base.logging.Logger;

/**
 * Simple utility class to assign with some common JSON operations.
 *
 * @author iganza
 */
@Component
public class JsonHelper {

   

    public JsonHelper() {
    }

    public JsonHelper(ObjectMapper mapper) {
        this.mapper = mapper;
    }

    @Autowired
    private ObjectMapper mapper;

    @SuppressWarnings("rawtypes")
    public List readAndMapArray(String json, Class<?> element) throws Exception {

        try {
            List list = mapper.readValue(
                json,
                mapper.getTypeFactory().constructCollectionType(List.class, element));
            if (list == null || list.size() == 0) {
                throw new NullPointerException("List of Object was null after mapper.readValue() call!");
            }
            return list;
        } catch (Exception e) {
            throw new  Exception(e);
        }
    }

    /**
     * Maps the given json to the given target. Exceptions are handled and re-thrown as {@link ResponseException}
     *
     * @param json The json to map
     * @param target The target class
     * @return A filled out instance of the target class
     * @throws Exception 
     */
    public Object readAndMapJson(String json, Class<?> target) throws Exception {

        try {
            Object o = mapper.readValue(json, target);

            // since the caller may try to cast, we need to watch out for the case when the returned object may be null
            if (o == null) {
                throw new NullPointerException("Object was null after mapper.readValue() call!");
            }

            return o;
        } catch (Exception e) {
            throw new Exception(e);
        }
    }

    public <T> T readAndMapJson(String json, Class<T> target, String rootName, boolean useEnumToString) throws Exception {

        ObjectReader reader = mapper.readerFor(target);

        if (null!=rootName || rootName != "") {
            reader = reader.withRootName(rootName);
        }

        if (useEnumToString) {
            reader = reader.with(DeserializationFeature.READ_ENUMS_USING_TO_STRING);
        }

        return readClass(json, reader);
    }

    public String writeValueAsString(Object value) {

        try {
            return mapper.writeValueAsString(value);
        } catch (JsonProcessingException e) {
           

            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    /**
     * A way of wrapping like objects into strings with separate root names.
     *
     * @param rootName
     * @param wrappedObject
     * @param <T>
     * @return
     */
    public <T> String writeValueWithRootName(String rootName, T wrappedObject) {

        Map<String, T> map = Collections.singletonMap(rootName, wrappedObject);

        return writeValueAsString(map);
    }

    protected <T> T readClass(String json, ObjectReader reader) throws Exception {

        try {
            T t = reader.readValue(json);
            // since the caller may try to cast, we need to watch out for the case when the returned object may be null
            if (t == null) {
                throw new NullPointerException("Object was null after mapper.readValue() call!");
            }
            return t;
        } catch (Exception e) {
            throw new Exception(e);
        }
    }
}
