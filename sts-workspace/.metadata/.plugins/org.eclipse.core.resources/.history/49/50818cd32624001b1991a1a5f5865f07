package com.lyncwork.services.store.service;

import com.lyncwork.services.store.domain.Role;
import com.lyncwork.services.store.domain.Team;
import com.lyncwork.services.store.domain.Workflow;
import com.lyncwork.services.store.repository.WorkflowRepository;
import com.lyncwork.services.store.repository.WorkflowTaskRepository;
import com.lyncwork.services.store.service.dto.*;
import com.lyncwork.services.store.service.errors.BusinessException;
import com.lyncwork.services.store.service.mapper.RoleMapper;
import com.lyncwork.services.store.service.mapper.TeamMapper;
import com.lyncwork.services.store.service.mapper.WorkflowMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Service Implementation for managing {@link Workflow}.
 */
@Service
@Transactional
public class WorkflowService {

    @Autowired
    private WorkflowTaskRepository workflowTaskRepository;

    @Autowired
    private RoleMapper roleMapper;

    @Autowired
    private TeamMapper teamMapper;

    @Autowired
    private MessageSource messageSource;

    private final Logger logger = LoggerFactory.getLogger(WorkflowService.class);

    private final WorkflowRepository workflowRepository;

    private final WorkflowMapper workflowMapper;



    public WorkflowService(WorkflowRepository workflowRepository, WorkflowMapper workflowMapper) {
        this.workflowRepository = workflowRepository;
        this.workflowMapper = workflowMapper;
    }

    /**
     * Save a workflow.
     *
     * @param workflowDTO the entity to save.
     * @return the persisted entity.
     */
    public WorkflowDTO save(WorkflowDTO workflowDTO) {
        logger.debug("Request to save Workflow : {}", workflowDTO);

        if (!areTheUniqueKeysValid(workflowDTO)){
            throw new BusinessException(messageSource.getMessage("workflow.uniquekey.validation", null, null), Workflow.class.getSimpleName(), "uniqueconstraintviolation");
        }

        Workflow workflow = workflowMapper.toEntity(workflowDTO);

        //Removing the WorkflowTasks when we are updating Workflow
        if (workflow.getId() != null){
            Optional<Workflow> optWorkflow = workflowRepository.findById(workflow.getId());
            if (optWorkflow != null && !optWorkflow.isEmpty()){
                Workflow w = optWorkflow.get();
                if (!CollectionUtils.isEmpty(w.getWorkflowTasks())) {
                    w.getWorkflowTasks().removeAll(workflow.getWorkflowTasks());
                    w.getWorkflowTasks().stream().forEach(wt -> {
                        workflowTaskRepository.delete(wt);
                    });
                }
            }
        }

        workflow = workflowRepository.save(workflow);
        return workflowMapper.toDto(workflow);
    }

    /**
     * Get all the workflows.
     *
     * @return the list of entities.
     */
    @Transactional(readOnly = true)
    public List<WorkflowDTO> findAll() {
        logger.debug("Request to get all Workflows");
        return workflowRepository.findAll().stream()
                                 .map(workflowMapper::toDto)
                                 .collect(Collectors.toCollection(LinkedList::new));
    }




    /**
     * Get all the workflows by roles or teams.
     *
     * @return the list of entities.
     */
    @Transactional(readOnly = true)
    public List<WorkflowDTO> findAll(Set<RoleDTO> rolesDTO, Set<TeamDTO> teamsDTO) {
        logger.debug("Request to get all Workflows by Roles or Teams");

        Set<Role> roles = new HashSet<Role>();
        if (!CollectionUtils.isEmpty(rolesDTO)) {
            roles = rolesDTO.stream()
                .map(roleMapper::toEntity)
                .collect(Collectors.toSet());
        }

        Set<Team> teams = new HashSet<Team>();
        if (!CollectionUtils.isEmpty(teamsDTO)) {
            teams = teamsDTO.stream()
                .map(teamMapper::toEntity)
                .collect(Collectors.toSet());
        }

        return workflowRepository.findDistinctByRolesInOrTeamsIn(roles, teams).stream()
            .map(workflowMapper::toDto)
            .collect(Collectors.toCollection(LinkedList::new));
    }

    /**
     * Get one workflow by id.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    @Transactional(readOnly = true)
    public Optional<WorkflowDTO> findOne(Long id) {
        logger.debug("Request to get Workflow : {}", id);
        return workflowRepository.findById(id)
            .map(workflowMapper::toDto);
    }

    /**
     * Delete the workflow by id.
     *
     * @param id the id of the entity.
     */
    public void delete(Long id) {
        logger.debug("Request to delete Workflow : {}", id);
        workflowRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public boolean existsByRole(Long roleId) {
        logger.debug("Request to exists Workflow assigned with a Role: {}", roleId);
        return workflowRepository.existsByRoles_Id(roleId);
    }

    @Transactional(readOnly = true)
    public boolean existsByTeam(Long teamId) {
        logger.debug("Request to exists Workflow assigned with a Team: {}", teamId);
        return workflowRepository.existsByTeams_Id(teamId);
    }

    @Transactional(readOnly = true)
    public boolean existsByTask(Long taskId) {
        logger.debug("Request to exists Workflow assigned with a Task: {}", taskId);
        return workflowRepository.existsByWorkflowTasks_Task_Id(taskId);
    }

    /**
     * Verify if exists at least one workflow by workflowName.
     *
     * @param workflowName the name of the entity.
     * @return the entity.
     */
    @Transactional(readOnly = true)
    public boolean existsByName(String workflowName) {
        logger.debug("Request to verify if Workflow exists by name: {} ", workflowName);
        return workflowRepository.existsByWorkflowNameIgnoreCase(workflowName);
    }

    /**
     * Verify if exists at least one workflow by workflowName with different id.
     *
     * @param id the id of the entity.
     * @param workflowName the name of the entity.
     * @return the entity.
     */
    @Transactional(readOnly = true)
    public boolean existsByNameAndIdNot(String workflowName, Long id) {
        logger.debug("Request to verify if Workflow exists by name with different id: {} ", workflowName);
        return workflowRepository.existsByWorkflowNameIgnoreCaseAndIdNot(workflowName, id);
    }

    @Transactional(readOnly = true)
    public EntityCheckedResponse checkUniqueKey(WorkflowDTO workflowDTO){
        EntityCheckedResponse result = new EntityCheckedResponse();

        Boolean valid = areTheUniqueKeysValid(workflowDTO);

        result.setValid(valid);
        result.setType(EntityCheckedResponse.Type.UNIQUE_KEY);

        if (!valid) {
            result.setMessage(messageSource.getMessage("workflow.uniquekey.validation", null, null));
        }

        return result;
    }

    @Transactional(readOnly = true)
    long count(){
        return workflowRepository.count();
    }

    private boolean areTheUniqueKeysValid(WorkflowDTO workflowDTO){
        if (workflowDTO.getId() == null){
            return !existsByName(workflowDTO.getWorkflowName());
        } else {
            return !existsByNameAndIdNot(workflowDTO.getWorkflowName(), workflowDTO.getId());
        }
    }

}
